#include <dirent.h>
#include <cstring>
#include <map>
#include <vector>

#include "../include/Image.hpp"
#include "../include/ImageClass.hpp"
#include "../include/CNNLayer.hpp"
#include "../include/IO.hpp"
#include "../include/Util.hpp"

using std::map;
using std::vector;
using std::pair;

int main(int argc, char* argv[]){
  pair<map<string,Image>,map<string,CNNLayer> > data;

  time_t t_init;
  time(&t_init);
  IO::loadLayersFromTXTFile(argv[1], data.second);
  time_t t_end;
  time(&t_end);
  double t_diff = difftime (t_end,t_init);
  printf("Load layers took %f\n",t_diff);
  
  time(&t_init);
  IO::loadImagesFromTXTFile(argv[2], data.first);
  time(&t_end);
  printf("Load images took %f\n",difftime (t_end,t_init));
  
  time(&t_init);
  IO::readAndSetImageClasses(argv[3], data.first);
  time(&t_end);
  printf("Read & set image classes took %f\n",difftime (t_end,t_init));
  
  time(&t_init);
  map<string,ImageClass> imageClasses;
  Util::computeImageClasses(data.first, data.second , imageClasses);
  time(&t_end);
  printf("Compute image classes took %f\n",difftime (t_end,t_init));



  //for(map<string,ImageClass>::iterator it = imageClasses.begin(); it!=imageClasses.end(); it++){
  //  it->second.printAccumulatedMeanAct();
  //}

  time(&t_init);
  for(map<string,ImageClass>::iterator it = imageClasses.begin(); it!=imageClasses.end(); it++){
    pair<ImageClass,float> closest = it->second.findClosestClassByEucliDist(imageClasses, data.second);
    printf("Closest class to %s is %s at distance %f\n",it->first.c_str(),closest.first.getName().c_str(),closest.second);
  }
  time(&t_end);
  printf("Compute image classes took %f\n",difftime (t_end,t_init));


///////////////////////////////////////////////////////////
////EXAMPLES FOR REFERENCE. DO NOT MODIFY. COPY & REUSE////
///////////////////////////////////////////////////////////

  //LOAD TXT (CAFFE OUTPUT) DATA
  //Load CNN layers, feature, and their activations, from txt files (directory/directory/layers_activations)
  //Computes statistics for each feature (mean, absolute deviation, standard deviation, activation threshold)
  //IO::loadLayersFromTXTFile(argv[1], data.second);

  //Load images activations from txt files  (directory/directory/layers_activations). 
  //IO::loadImagesFromTXTFile(argv[1], data.first);
  
  //Load images & CNN layers (features, stats, etc.) from the same set of txt files. May be a biased approach.
  //IO::loadImagesAndLayersFromTXTFile(argv[1],data.first, data.second);


  //LOAD CLASS LABEL DATA (PREVIOUSLY CURATED)  
  //Read image classes names from a two column txt file for previously loaded images. Updates image data
  //IO::readAndSetImageClasses(argv[1], data.first);


  //STORE GRAPH-LIKE DATA
  //Write images as vertices in a txt file (one column file of image names)
  //IO::writeImagesVerticesToTXTFile(argv[1],data.first);

  //Write CNN features as vertices in a txt file (one column file of feature ids)
  //IO::writeLayersVerticesToTXTFile(argv[1],data.second);

  //Write both images and features as vertices in txt file (one column, image names and feature ids)
  //IO::writeImagesAndLayersVerticesToTXTFile(argv[1], data.first, data.second);

  //Write both images and features as edges in txt file (two columns, image names - relevant features ids)
  //IO::writeImagesAndLayersEdgesToTXTFile(argv[1],data.first,data.second);


  //STORE BINARY DATA
  //Store basic CNN data (layers, features, and statistics) to a binary file
  //IO::writeLayersToBinaryFile(argv[1],data.second);

  //Store ImageClass data to a binary file
  //IO::writeImageClassToBinaryFile(argv[1],imageclass);


  //LOAD BINARY DATA (PREVIOUSLY GENERATED BY TIRAMISU)
  //Load CNN layers (features, stats, etc.) from a binary file previously generated.
  //IO::loadLayersFromBinaryFile(argv[1],data.second);


  //OPERATIONS ON IMAGES
  //Computes the relevant features (those beyond activation threshold) of images
  //for(map<string,Image>::iterator it = data.first.begin(); it!=data.first.end(); it++){
  //  it->second.computeRelevantFeatures(data.second);
  //}

  //Find the euclidean distance between the raw activations of two images
  //Image img1,img2;
  //float euclDist = Util::euclideanDistanceImageActivations(data.second, img1, img2);



  //OPERATIONS ON IMAGE CLASSES
  //Generate one image class representation by computing the mean activations of a set of images (labeled or unlabeled)
  //ImageClass imageclass;
  //imageclass.computeMeanActivations(data.first, data.second);

  //Find the closest image class by euclidean distance to one from within a set
  //vector<ImageClass> iClassCandidates;
  //ImageClass closest = imageclass.findClosestClassByEucliDist(iClassCandidates, data.second);
  //map<string,ImageClass> iClassCandidates;
  //ImageClass closest = imageclass.findClosestClassByEucliDist(iClassCandidates, data.second);

  //Find the euclidean distance between two image classes
  //ImageClass imgc1, imgc2;
  //float euclDist = Util::euclideanDistanceImageClass(data.second, imgc1, imgc2);

  //Build all image classes from a set of labeled images
  //map<string,ImageClass> imageClasses;
  //Util::computeImageClasses(data.first, data.second , imageClasses);




  //PRINT INTERMEDIATE DATA
  //Print features data 
  //for(map<string,CNNLayer>::iterator it = data.second.begin();it!=data.second.end();it++){
  //  it->second.exploreCNNLayer();
  //}

  //Print layer data
  //for(map<string,CNNLayer>::iterator it = data.second.begin();it!=data.second.end();it++){
  //  map<int,CNNFeature> feats = it->second.getFeaturesDyn();
  //  //printf("layer %s has %u features\n",it->first.c_str(),feats.size());
  //  for(map<int,CNNFeature>::iterator it2=feats.begin(); it2!=feats.end();it2++){
  //    CNNFeature f = it2->second;
  //    printf("Mean: %f StdDev:%f LayerName:%s FeatureId:%u\n",
  //      f.getMean(),f.getStdDev(),it->first.c_str(),f.getId());
  //  }
  //}

  //Print relevant features of images
  //for(map<string,Image>::iterator it = data.first.begin(); it!=data.first.end(); it++){
  //  printf("Image %s\n",it->first.c_str());
  //  it->second.computeRelevantFeatures(data.second);
  //  map<string,map<int,float> > rels = it->second.getRelevantFeaturesDyn();
  //  int total_counter = 0;
  //  for(map<string,map<int,float> >::iterator it2 = rels.begin(); it2!=rels.end(); it2++){
  //    printf(" Layer %s\n",it2->first.c_str());
  //    map<int,float> vals = it2->second;
  //    int counter = 0;
  //    for(map<int,float>::iterator it3 = vals.begin(); it3!=vals.end(); it3++){
  //      pair<float,float> stats = data.second[it2->first.c_str()].getFeatMeanAbsDev(it3->first);
  //      //printf("  RelFeat %u %f (real mean %f stdDev %f)\n",it3->first,it3->second,
  //      //stats.first,stats.second);
  //      counter++;
  //    }
  //    total_counter += counter;
  //    printf(" Num rel feats %u\n",counter);
  //  }
  //  printf(" Total rel feats %u\n",total_counter);
  //}


  //UTIL (not tiramisu-specific)
  //Generate random string
  //char rand_name[5];
  //Util::generate_random_string(rand_name,5);
  //string filename = string(argv[1])+"somefile_"+string(rand_name)+".tir";

  //Calculate computing time
  //time_t t_init;
  //time(&t_init);
  //time_t t_end;
  //time(&t_end);
  //double t_diff = difftime (t_end,t_init);
  //printf("%f\n",t_diff);
  
}  

